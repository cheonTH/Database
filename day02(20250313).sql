CREATE TABLE "USER"(
	ID VARCHAR2(100) PRIMARY KEY,
	PW VARCHAR2(100),
	ADRESS VARCHAR2(300),
	EMAIL VARCHAR2(300),
	BIRHT DATE
);

CREATE TABLE PRODUCT(
	PRODUCT_NUM NUMBER PRIMARY KEY,
	PRODUCT_NAME VARCHAR2(300),
	PRODUCT_PRICE NUMBER,
	PRODUCT_COUNT NUMBER
);

CREATE TABLE "ORDER"(
	ORDER_NUM NUMBER PRIMARY KEY,
	ORDER_DATE DATE,
	USER_ID VARCHAR2(100),
	PRODUCT_NUM NUMBER,
	CONSTRAINT USER_FK FOREIGN KEY(USER_ID) REFERENCES "USER"(ID),
	CONSTRAINT PRODUCT_FK FOREIGN KEY(PRODUCT_NUM) REFERENCES PRODUCT(PRODUCT_NUM)
);

DROP TABLE PRODUCT;

-- FLOWER, POT TABLE
CREATE TABLE FLOWER(
	FLOWER_NAME VARCHAR2(300) PRIMARY KEY,
	FLOWER_COLOR VARCHAR2(200),
	FLOWER_PRICE NUMBER
);

CREATE TABLE POT(
	POT_ID NUMBER PRIMARY KEY,
	POT_COLOR VARCHAR2(200),
	POT_SHAPE VARCHAR2(300),
	FLOWER_NAME VARCHAR2(300),
	CONSTRAINT POT_FK FOREIGN KEY(FLOWER_NAME) REFERENCES FLOWER(FLOWER_NAME)
);

SELECT *
FROM FLOWER;

SELECT *
FROM POT;

SELECT *
FROM EMPLOYEES EMP;

-- EMPLOYEES테이블에서 이름 직종 급여
SELECT FIRST_NAME AS NAME, JOB_ID AS JOB, SALARY AS SAL
FROM EMPLOYEES;
-- 사원테이블에서 사번 이름 입사일 급여를 조회
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, SALARY
FROM EMPLOYEES e ;

-- 사원테이블에서 사번 이름직종 급여 보너스비율, 실제 보너스
SELECT SALARY,
		COMMISSION_PCT,
		SALARY * COMMISSION_PCT AS COMM
FROM EMPLOYEES;

-- 사원테이블에서 급여가 10000이상인 사원들의 정보 사번, 이름, 급여순
SELECT EMPLOYEE_ID,
		FIRST_NAME,
		SALARY
FROM EMPLOYEES
WHERE SALARY >= 10000;

-- 사원테이블에서 이름이 MICHAEL인 사원의 사번, 이름 ,급여를 조회
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE FIRST_NAME = 'Michael';

-- 사원테이블에서 직종이 it_prog인 사원들의 정보를 사번 이름 직종 급여순으로 출력
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY
FROM EMPLOYEES 
WHERE JOB_ID = 'IT_PROG';

-- 급여가 10000이상 13000이하인 사원의 정보 사원번호 이름 급여순 조회
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES 
WHERE SALARY >= 10000 AND SALARY <= 13000;

-- 입사일이 05년 9월 21일인 사원의 정보 사번, 이름, 입사일
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM EMPLOYEES 
WHERE HIRE_DATE = '2005-09-21';

-- 직종이 SA_MAN 이거나 IT_PROG인 사원의 모든 정보
SELECT *
FROM EMPLOYEES
WHERE JOB_ID = 'SA_MAN' OR JOB_ID = 'IT_PROG';
-- 급여가 2200, 3200, 5000, 6800 받는 사원의 정보를 사번, 이름, 직종, 급여순으로 조회
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY
FROM EMPLOYEES 
WHERE SALARY = 2200 OR SALARY = 3200 OR SALARY = 5000 OR SALARY  = 6800;

-- SQL 연산자
-- 1. BETWEEN : A와 B사이의 값을 조회할 때 사용
-- 2. IN: OR를 대신해서 사용하는 연산자
-- 3. LIKE: 유사검색

-- 사원테이블 06년도 입사한 사원들의 정보 사번, 이름 ,직종, 입사일
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, HIRE_DATE
FROM EMPLOYEES 
WHERE HIRE_DATE BETWEEN '2006-01-01' AND '2006-12-31';

SELECT FIRST_NAME, JOB_ID
FROM EMPLOYEES 
WHERE JOB_ID IN ('SA_MAN', 'IT_PROG');

WHERE JOB_ID = 'SA_MAN' OR JOB_ID = 'IT_PROG';
-- 급여가 2200, 3200, 5000, 6800 받는 사원의 정보를 사번, 이름, 직종, 급여순으로 조회
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY
FROM EMPLOYEES 
WHERE SALARY IN (2200, 3200, 5000, 6800);

-- LIKE (유사검색): 쿼리문에 WHERE절에 주로 사용도되며 부분적으로 일치하는 속성을 찾을 때 사용
-- %:모든 값, _:하나의 값
-- %A: A로 끝나는, A%: A로 시작, %A%: A를 포함 %A%B%: A와B를 포함하고있는 모든 값
-- A_: A로 시작하는 두글자, A__:A로 시작하는 세글자 _A_: 두번쩨 글자에 A가 들어가는 세글자 짜리 데이터

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY
FROM EMPLOYEES 

-- 사원들의 이름중 M으로 시작하는 사원들의 정보 사번, 이름 ,직종
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID
FROM EMPLOYEES 
WHERE FIRST_NAME LIKE 'M%';

-- 이름이 D로 끝나는 사원의 사번 이름 직종
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID
FROM EMPLOYEES 
WHERE FIRST_NAME LIKE '%d';

-- 이름에 A가 포함되어 있는 사원의 정보를 이름,직종순으로 조회
SELECT FIRST_NAME, JOB_ID
FROM EMPLOYEES 
WHERE FIRST_NAME LIKE '%a%' OR FIRST_NAME LIKE '%A%';

-- 이름에 소문자O가 들어가면서 A로 끝나는 사원의 정보 이름 급여순
SELECT FIRST_NAME,SALARY
FROM EMPLOYEES 
WHERE FIRST_NAME LIKE '%o%' AND FIRST_NAME LIKE '%a' ;

-- 이름이 H로 시작하면서 6글자 이상인 사원의 정보 사번, 이름
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES 
WHERE FIRST_NAME LIKE 'H_____%';

-- 사원테이블에서 이름이 S가 포함되어있지 않은 사원들  사번 이름
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES 
WHERE FIRST_NAME NOT LIKE '%s%';

-- OR연산자를 통해 여러개의 LIKE조건을 연결가능
SELECT EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES 
WHERE FIRST_NAME LIKE '%el%' OR FIRST_NAME LIKE '%en' ;

-- INSERT
-- 테이블에 데이터를 추가하는 문법
-- INSERT INTO 테이블명(컬럼명1, 컬럼명2...)
-- VALUES(데이터)

SELECT *
FROM TBL_STUDENT;

-- 성별은 'M' 또는 'W'만 들어갈 수 있다 -> 이유: CHECK제약조건
INSERT INTO TBL_STUDENT (
	ID,
	NAME,
	MAJOR,
	GENDER,
	BIRTH
)
VALUES(0,'홍길동','컴공','M',TO_DATE('1980-01-02','YYYY-MM-DD'));

-- PK로 지정된 컬럼에는 값이 겹치거나 비워둘 수 없음
INSERT INTO TBL_STUDENT (
	ID,
	NAME,
	MAJOR,
	GENDER,
	BIRTH
)
VALUES(1,'허춘삼','컴공','W',TO_DATE('1980-01-02','YYYY-MM-DD'));

INSERT INTO TBL_STUDENT (
	ID,
	NAME,
	MAJOR,
	GENDER,
	BIRTH
)
VALUES(2,'김마루','컴공','M',TO_DATE('2000-12-30','YYYY-MM-DD'));

INSERT INTO TBL_STUDENT (
	ID,
	NAME,
	MAJOR,
	BIRTH
)
VALUES(3,'박정민','컴공',TO_DATE('1980-01-02','YYYY-MM-DD'));

-- 꽃테이블
INSERT INTO FLOWER (
	FLOWER_NAME,
	FLOWER_COLOR,
	FLOWER_PRICE
)
VALUES('장미꽃', '빨간색', 3000);

INSERT INTO FLOWER (
	FLOWER_NAME,
	FLOWER_COLOR,
	FLOWER_PRICE
)
VALUES('해바라기', '노란색', 2000);

-- INSERT ALL
-- INTO 테이블명(컬럼명)VALUES(값)
-- SELECT * FROM DUAL;
-- DUAL 테이블을 이용한 SELECT구문은 단일행을 반환하여 각 INTO절이 한번씩 실행되도록 함
INSERT ALL
INTO FLOWER(FLOWER_NAME,
			FLOWER_COLOR,
			FLOWER_PRICE)
VALUES('안개꽃', '흰색', 4000)
SELECT * FROM DUAL;

SELECT *
FROM FLOWER;

INSERT INTO POT (
	POT_ID,
	POT_COLOR,
	POT_SHAPE,
	FLOWER_NAME
)
VALUES(202503130003, '흰색', '네모','해바라기');


SELECT *
FROM POT;

--DELETE FROM 테이블명 WHERE 조건;
--외래키로 참조되고 있을 때 자식 테이블에서 참조되고있는 행을 먼저 삭제해야 부모 테이블에서 삭제할 수 있음
--DELETE문에 조건을 쓰지 않으면 의도하지 않게 모든 데이터가 날아갈 수 있음.
DELETE 
FROM FLOWER 
WHERE FLOWER_NAME = '장미꽃';

--UPDATE
--UPDATE 테이블명  SET 컬럼명 = '변경값' WHERE 조건;

-- TBL_STUDENT 테이블에서 홍길동의 전공을 경영학과로 수정
UPDATE TBL_STUDENT
SET MAJOR = '경영'
WHERE NAME = '홍길동';

SELECT *
FROM TBL_STUDENT;

DELETE FROM POT 
WHERE FLOWER_NAME = '장미꽃';
--테이블 사이에는 관계라는 개념이 존재
--관계는 일대일(1:1), 일대다(1:N), 다대다(N:M)의 관계가 있음

--일대일관계
--두 테이블 A와 B가 있을 때 A의 정보와 B의 정보 하나가 연결된 관계
--EX)한 사람은 하나의 여권만 소지할수 있고 하나의 여권은 한 사람에게만 발급됨

--일대다관계
--테이블 A의 레코드(행) 하나가 B의 여러행과 연결되는 관계
--EX)한 사람이 여러개의 부동산을 가질 수 있음 집은 주인이 한명, 한사람이 여러개의 물건을 주문할 수 있음
 
--다대다관계
--테이블 A의 행 하나가 테이블B의 행 여러개와 테이블B의 행 하나가 테이블 A의 행 여러개와 연결된 관계
--EX)학생과 강의의 관계 한한생이 여러강의를 수강할 수 있음. 그리고 하나의 강의는 여러 학생들이 들을 수 있음.
--다대다 관계는 두개의 테이블사이에서 직접구현할 수 없으므로 연결 테이블을 사용하여 테이블 A와 B를 연결
--연결 테이블은 두 테이블의 기본키를 외래키로 포함하여 복합 기본키로 지정하는 경우가 많다

--1. 정답 1
--2. 
CREATE TABLE CD (
	TITLE VARCHAR2(255) PRIMARY KEY,
	PRICE NUMBER,
	GENRE VARCHAR2(100),
	TRACKLIST VARCHAR2(255),
	ARTISTNAME VARCHAR2(255),
	CONSTRAINT CD_FK FOREIGN KEY(ARTISTNAME) REFERENCES ARTIST(NAME)
);

CREATE TABLE ARTIST (
	NAME VARCHAR2(255) PRIMARY KEY,
	COUNTRY VARCHAR2(255),
	DEBUTYEAR DATE
);

CREATE TABLE TRACK (
	TITLE VARCHAR2(255) PRIMARY KEY,
	RUNNING_TIME NUMBER,
	CD_TITLE VARCHAR2(255),
	CONSTRAINT TRACK_FK FOREIGN KEY(CD_TITLE) REFERENCES CD(TITLE)
);

SELECT *
FROM CD;
SELECT *
FROM ARTIST;
SELECT *
FROM TRACK;

--3.
CREATE TABLE DEPT (
	DeptID NUMBER PRIMARY KEY,
	DeptName VARCHAR2(255)
);

CREATE TABLE EMPLOYEE (
	EMPID NUMBER PRIMARY KEY,
	EMPNAME VARCHAR2(255),
	"POSITION" VARCHAR2(255),
	DeptID NUMBER,
	CONSTRAINT EMP_FK FOREIGN KEY(DeptID) REFERENCES DEPT(DeptID)
);

CREATE TABLE DEPENDENT (
	NAME VARCHAR2(255),
	AGE NUMBER,
	EMPID NUMBER,
	CONSTRAINT DEPENDENT_FK FOREIGN KEY(EMPID) REFERENCES EMPLOYEE(EMPID)
);

CREATE TABLE WORKRECORD (
	PERIOD DATE,
	EMPID NUMBER,
	CONSTRAINT WORKRECORD FOREIGN KEY(EMPID) REFERENCES EMPLOYEE(EMPID)
);

--4.
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY
FROM EMPLOYEES 
WHERE SALARY >= 1500;
--5
SELECT FIRST_NAME, JOB_ID
FROM EMPLOYEES
WHERE MANAGER_ID IS NULL;
--6
SELECT FIRST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
WHERE JOB_ID IN ('IT_PROG', 'SA_MAN') AND SALARY NOT IN(1000,3000,5000);
--7.
SELECT *
FROM PRODUCT;

CREATE TABLE PRODUCT_2 (
	"NO" NUMBER PRIMARY KEY,
	NAME VARCHAR2(255),
	PRICE NUMBER,
	P_DATE DATE
);

INSERT ALL
INTO PRODUCT_2(NO, NAME, PRICE, P_DATE)
VALUES(1000, '컴퓨터', 100 , '2021-04-15')
VALUES(1002, '냉장고', 200 , '2021-03-29')
VALUES(1000, '에어컨', 300 , '2020-12-15')
VALUES(1000, '오디오', 20 , '2020-12-15')
VALUES(1000, '세탁기', 100 , '2021-04-15')
SELECT * FROM DUAL;

INSERT INTO TBL_STUDENT (NO, NAME, PRICE, P_DATE)
VALUES(1000, '컴퓨터', 100 , '2021-04-15');